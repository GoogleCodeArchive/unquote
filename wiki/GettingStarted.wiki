#summary Quick steps for installing and using Unquote.
#labels Featured

= Getting Started =

== Installation == 

Note: Unquote targets the .NET 4.0 runtime and depends on FSharp.Core (version 2.0.0.0, .NET 4.0 build) and FSharp.PowerPack.Linq (version 2.0.0.0, .NET 3.5 build).

  * Download and unzip featured release of Unquote from the [http://code.google.com/p/unquote/downloads/list Downloads] page OR install the latest version of the [http://www.nuget.org/List/Packages/Unquote Unquote NuGet package].
  * If not installed already, install the [http://fsharppowerpack.codeplex.com/ F# PowerPack] May 2010 release which includes the FSharp.PowerPack.Linq dependency.
  * To use within FSI, locate and add references to Unquote.dll and FSharp.PowerPack.Linq.dll using the `#r` directive. Make sure you are running build 4.0 or greater of FSI.
  * To use within an F# test project, first locate and add a reference to Unquote.dll OR install the package via NuGet which will add the reference itself. Next add a GAC reference to FSharp.PowerPack.Linq (note: the Unquote NuGet package does not currently enforce this dependency). Finally, add a reference to xUnit.net or NUnit or whichever unit testing framework assemblies you choose. Make sure the test project targets the .NET 4.0 runtime.

== Using ==

Open `Swensen.Unquote` within FSI session or top of unit test file, this will automatically open `Swensen.Unquote.Operators`. The `test` and `raises` operators and the `xx?` series binary infix operators can be used within FSI sessions or within supported unit testing framework test methods to perform boolean assertions (if INTERACTIVE compiler symbol defined, then output to FSI; else if xUnit or NUnit loaded in currently executing assembly, then use appropriate test failed methods; else throw Exception).

  * `val source : Quotations.Expr -> string`
{{{
> source <@ (1+2)/3 @>;;
val it : string = "(1 + 2) / 3"
}}}

  * `val reduce : Quotations.Expr -> Quotations.Expr`
{{{
> <@ (1+2)/3 @> |> reduce |> source;;
val it : string = "3 / 3"
}}}

  * `val reduceFully : Quotations.Expr -> Quotations.Expr list`
{{{
> <@ (1+2)/3 @> |> reduceFully |> List.map source;;
val it : string list = ["(1 + 2) / 3"; "3 / 3"; "1"]
}}}

  * `val isReduced : Quotations.Expr -> bool`
{{{
> <@ (1+2)/3 @> |> isReduced;;
val it : bool = false
> <@ 1 @> |> isReduced;;
val it : bool = true
}}}

  * `val unquote : Quotations.Expr -> unit`
{{{
> unquote <@ (1+2)/3 @>;;

(1 + 2) / 3
3 / 3
1

val it : unit = ()
}}}

  * `val inline test : Quotations.Expr<bool> -> unit`
{{{
> test <@ (1+2)/3 = 1 @>;;
val it : unit = ()
> test <@ (1+2)/3 = 2 @>;;

Test failed:
	
(1 + 2) / 3 = 2
3 / 3 = 2
1 = 2
false

val it : unit = ()
}}}

  * `val inline ( =? ) : 'a -> 'a -> unit when 'a : equality`
{{{
> [1;2;3;4] =? [4;3;2;1];;

Test failed:

[1; 2; 3; 4] = [4; 3; 2; 1]
false

val it : unit = ()
}}}
  * `val inline ( <? ) : 'a -> 'a -> unit when 'a : comparison`
  * `val inline ( >? ) : 'a -> 'a -> unit when 'a : comparison`
  * `val inline ( <=? ) : 'a -> 'a -> unit when 'a : comparison`
  * `val inline ( >=? ) : 'a -> 'a -> unit when 'a : comparison`
  * `val inline ( <>? ) : 'a -> 'a -> unit when 'a : equality`
  * `val inline raises<'a when 'a :> exn> : Quotations.Expr -> unit`
{{{
> raises<exn> <@ (null:string).Length @>;;
val it : unit = ()
> raises<NullReferenceException> <@ (null:string).Length @>;;
val it : unit = ()
> raises<System.ArgumentException> <@ (null:string).Length @>;;

Test failed:

Expected ArgumentException but got NullReferenceException

null.Length
System.NullReferenceException: Object reference not set to an instance of an object.

val it : unit = ()
> raises<exn> <@ 3 @>;;

Test failed:

Expected Exception but got nothing

3

val it : unit = ()
}}}

Some Unquote operators are also available as `Expr` extensions:
{{{
  type Expr with
    member ToSource : unit -> string
  type Expr with
    member Reduce : unit -> Quotations.Expr
  type Expr with
    member ReduceFully : unit -> Quotations.Expr list
  type Expr with
    member IsReduced : unit -> bool
}}}

Opening Swensen.Unquote also makes a `System.Type` extension available for printing F# style type signatures:

{{{
type Type with
  member FSharpName : string

> typeof<int>.FSharpName;;
val it : string = "int"
> typeof<int[]>.FSharpName;;
val it : string = "int[]"
> typeof<int[,,,]>.FSharpName;;
val it : string = "int[,,,]"
> typeof<System.Collections.Generic.Dictionary<string, float>>.FSharpName;;
val it : string = "Dictionary<string, float>"
> typeof<unit -> int -> string>.FSharpName;;
val it : string = "unit -> int -> string"
> typeof<unit -> (float -> int) -> string>.FSharpName;;
val it : string = "unit -> (float -> int) -> string"
> typeof<int * float * string>.FSharpName;;
val it : string = "int * float * string"
> typeof<int * (bool * float) * string>.FSharpName;;
val it : string = "int * (bool * float) * string"
> typeof<int -> (list<(int * (int -> string))[]> * string[,,])>.FSharpName;;
val it : string = "int -> list<(int * (int -> string))[]> * string[,,]"
}}}